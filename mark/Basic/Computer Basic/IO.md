### IO

IO调用（进程发起）和IO执行（操作系统）

### 输入类型IO的大致工作流程

* 进程向操作系统发起请求
* 操作系统把文件数据读取到内核中
* 操作系统吧内核数据拷贝到进程内核中
* 进程读取数据并处理数据
* 

### IO流程（输入输出以网络，进程以JAVA进程，系统以Linux为例）

#### 输入

* 网络数据到达网卡，存入网卡缓冲（Buffer）
* 操作系统读取缓冲数据，拷贝入内核缓冲
* 操作系统找到对应的处理进程（依据数据中本地端口号），并依据远程端口号来修改进程监听的事件状态（读，写，连接）或者是直接拷贝数据到对应进程内核中并触发回调事件（异步）
* 进程从内核中拿到监听事件状态变化，并从系统缓冲区拷贝数据，进入进程缓冲区。

#### 输出

* 进程写数据到缓冲区，直接调用flush 或者在数据累计到一定（时间和量决定）来刷新数据到系统内核缓冲区中。
* 内核缓冲区把数据刷到网卡缓冲区当中。

#### 操作系统IO状态

* 读取操作，操作系统将外部数据拷贝到进程缓冲区前，进程缓存区处于不可读状态（IO未就绪）

阻塞IO就是进程等待操作系统IO，非阻塞就是进程IO不等待系统IO状态，一直轮询来知晓状态。

#### 同步与异步（关注的是消息的通知机制）（自己等待通知结果有了，然后处理结果，还是出结果，直接处理完通知你）

#### 阻塞与非阻塞（关注的是程序操作结果的状态）（一直在那边等待结果，或者是做其他事，一边不断的结果）

***IO模型(Linux)***

* 阻塞式IO(调用recefrom,阻塞直到有数据，系统复制到用户空间)
* 非阻塞式IO（不停的调用recvfrom,）
* IO复用(select,poll,系统)(Netty 的实现方式)
* 信号驱动IO（应用建立信号处理程序，系统调用sigaction。内核准备好数据，系统调用recvfrom。用户调用，复制数据到用户态）（系统通过socket 上的注册信号调用方法，内核向进程发送sigio信号）
* 异步IO（应用发出aio_read信号量，直接返回。系统在数据处理复制完递交aio_read的信号量）

### JAVA  IO

***ByteBuffer***

* buffer 的capcity 永远不变

####    基于字节

####    流

* 节点流

* 过滤流

  


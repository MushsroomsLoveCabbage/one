#### 设计模式

##### 指导思想

- “组合优于继承”

##### 代码评定的原则

- 拓展性(Extensibilty)
- 可复用性(Reuseability) 
  - 继承，多态
- 简洁性（SImplity）
- 灵活性（Flexibility）
- 可维护性（Maintainability）
- 可读性（Readability）
- 可测试性（Testability）

##### 设计原则

- SOILD 原则
- SRP 单一职责原则
- OCP开闭原则
- LSP里式替换原则
- ISP 接口隔离原则
- DIP依赖导致原则

##### 设计模式分类

- 结构型
  - 代理(Proxy)(对现有的接口进行拓展,例如计时，预处理等都是与功能本身无关的)
  - 桥接 (Bridge) 将接口的抽象和实现Decouple ,（特别是多个要素可以变化时候，每个都可以独立变化）
  - 适配器(Adapter)（将不同的接口对应上），
  - 装饰（在现有接口基础上增加新的功能接口，或者对功能本身增强）
  - 亨元（复用对象节省内存），
  - 组合 （把对象组织成树型结构，以表示一种‘部分-整体’的层次结构）
  - 门面 Facade 封装实现，仅仅提供一个接口来供使用，隐藏实现细节
- 创建型
  - 单例，
  - 工厂，
  - 建造者
  - 原型
- 行为型
  - 观察者，
  - 模板，提供类的接口模板，由具体人来实现具体接口功能
    * 实现通用功能
    * 具体细节交由具体类实现
    * 回调函数(同步回调,异步回调)
  
  - 策略，提供一系列多个实现功能的类，由具体类型来决定选择哪个类
  - 职责链，遍历链表里所有实现类，来处理某个数据对象。
  - 迭代器，
  - 状态
    * 可以通过查表的方式
  - 访问者，
  - 备忘录，
  - 命令，把请求操作封装成单独的操作，由单独线程处理
  - 解释器，
  - 中介




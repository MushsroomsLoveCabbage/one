### The Google File System



#### 4. Master 节点操作

​     Master节点执行所有的名称空间操作。除此，它管理整个系统中的Chunk副本：决定Chunk的存储位置（放置在哪里），创建新的Chunk和它的副本，管理复制以及协调大量全系统的活动以保证Chunk被全量复制，在所有Chunk(块)服务器间进行负载均衡，回收所有未使用的存储空间。本节讨论上述的主题。

#### 4.1 名称空间管理和锁

* 许多Master 操作需要很长时间：例如，快照操作必须撤销Chunk(块)服务器上快照涉及的所有的Chunk的租约。（被快照覆盖的Chunk(块)服务器的租约）。我们不希望这些操作进行时，延迟其他Master节点的操作。因此我们允许多操作同时运行，通过使用名称空间的区域上的锁去保证正确的执行顺序。

* 不像其他传统的文件系统，GFS没有那种针对每个目录实现能够列出目录下所有文件列的数据结构。也不支持文件或者目录的链接（Unix 硬链接或者符号链接）逻辑上，GFS 的名称空间就是一个映射全路径名到原数据的查找表。通过前缀压缩，这个表可以高效的在内存中存储。名称空间树型结构上，每个节点（绝对文件名或者目录名）有一个关联的读写锁。

* 每个Master 操作执行前需要一系列的锁。例如：如果一个操作涉及 /d1/d2/.../dn/leaf,它将获取目录名/d1,/d1/d2,...,/d1/d2/.../dn,  上的读锁，并且再全路径名/d1/d2/.../dn/leaf 上的读锁或者写锁。注意，leaf 是一个文件还是一个目录取决于操作。

* 我们现在说明锁机制如何防止 /home/user/foo 文件被创建，当 /home/user 被快照到 /save/user。快照操作需要获得/home,/save上的读锁。以及 /home/user 和/save/user上的写锁。文件创建获取/home, /home/user 上的读锁。以及/home/user/foo 上的写锁。这两个操作将会顺序化执行因为它们尝试获得/home/users上的锁是冲突的。文件创建不需要获得父目录上的写锁，因为没有目录，或者像inode等禁止修改的数据结构。文件名上的读锁有效的防止了父目录被删除。
* 采用这种锁的优点是它允许同一目录上的并发的操作。比如在同个目录上可以同时创建多个文件：每个操作都获取目录名上的读锁以及文件名上的写锁。目录名上的读锁防止目录被删除，重命名或者被快照。文件名上的写锁序列化写操作，确保不会创建同名文件两次。
* 由于命名空间有许多节点，读写锁采用惰性分配（懒分配）策略，不再使用时立马删除。同样，锁在全序一致性下获取避免（防止）死锁：首先按命名空间的层次排序，同一层次下按字典（lexicographically）顺序排序。

#### 4.2 副本的位置

* 一个GFS集群是高度分布的多层次结构，而不是平面结构（一层）。典型的在多个不同机架中有上百的Chunk(块)服务器。这些Chunk(块)服务器被上百个来自相同或者不同的机架上的客户端轮流获取。不同机架上的机器间通信或者需要一次或者多次的网络交换机。另外一个机架上的出入带宽可能比机架上所有机器的加在一起的带宽低。多层次的分布式意味着对数据的灵活性，可靠性，可用性的一个特有挑战。
* Chunk副本的放置策略为了两个目的：最大的数据可靠性和可用性，最大的带宽利用率。为了两者。把副本分布在不同的机器上是不够的。这只能预防硬盘损坏或者机器失效以及最大化利用机器的带宽。我们必须把Chunk副本分配在不同的机架上。这保证了一些副本可以存活或者保持可用性当一个整个机架被破坏或者离线（例如,共享的资源 如网络交换机或者电源电路导致的问题）。这也意味着网络流量，特别是针对某个Chunk的读操作，可以利用多个机架的聚合带宽。另一方面写数据流必须流经多个机架。这是我们乐意做的取舍。

#### 4.3 创建，重新复制，重新负载均衡

* Chunk副本有三个创建的用途：Chunk创建，重新复制，重新负载均衡
* 当Master创建一个Chunk，选择哪里去放置初始化空副本。考虑几个因素。1.我们放置副本在磁盘使用率低的Chunk(块)服务器上。随着时间它会负载均衡Chunk(块)服务器间的磁盘使用2.我们想要限制每个Chunk(块)服务器上的最近创建的数量。尽管创建本身容易。但随之而来的事大量写入流量因为Chunk在Writer真正写入数据时候才被创建。并且在我们的一次追加读多次的工作模式下，他们一旦被完全的写入后成为只读的。3.综上所述，我们想要一份Chunk的分布副本在多机架上。
* 当Chunk的有效副本数量降到用户指定的数目以下，Master 会再复制Chunk。这可能因为多个原因发生：一个Chunk(块)服务器变的不可获得，他报告他的副本损坏了，它的磁盘因为错误变得不可用，或者复制因素增加了。每个需要被再复制的Chunk基于几个因素被优先级排序的。一个就是离复制目标差有多大.例如：我们给更高的优先级给丢失了两个副本的Chunk而不是丢失一个的。另外，我们选择先复制Chunk的活跃文件而不是刚被删除文件的Chunk。最后为了最小化失败对于运行的应用的影响，我们提高任何正在阻塞客户单进程的Chunk的优先级。
* Master 采用优先级最高的Chunk，命令Chunk(块)服务器去复制Chunk数据直接从可用的副本。新的副本的放置策略和被创建出来的类似。平衡磁盘利用率，限制单个Chunk(块)服务器上的有效的复制操作，机架上的分布副本。为了避免复制流量压倒客户端流量。Master 限制集群以及Chunk(块)服务器上有效的复制操作数量。每个Chunk(块)服务器通过限制它对于原Chunk的读请求频率来限制在复制操作上所占用的带宽。
* 最后，Master 周期性的对副本进行负载均衡： 他检验现在的副本的分布并且移动副本以来为了更好的利用磁盘空间和负载均衡。同样通过这个操作，Master缓慢的填满一个新的Chunk(块)服务器而不是用新Chunk立即填满它,与之而来的高写流量。新副本的放置策略就像上面所讨论的。另外Master 必须选择移除哪一个副本。正常来说，它选择移除那些Chunk(块)服务器上剩余空间低于平均值的来平衡磁盘空间使用



#### 4.4 垃圾收集

* 在文件被删除后，GFS不会立马回收物理空间。GFS空间回收采用惰性策略，只在文件和Chunk层上定期的垃圾收集时进行。我们发现这种方式使得系统更加的简单，可靠。

#### 4.4.1 机制

* 当一个文件被应用删除，Master 像记录其他操作一样，立刻以日志方式记录删除操作。然而，Master 不会立刻回收资源这个文件，而仅仅时把文件重命名为一个带有删除时间戳的隐藏名。在Master定期扫描文件系统命名空间，它将删除隐藏文件如果它们已经存在超过三天（时间间隔可配置）。直到被删除，文件始终可以被读通过一个新的特别的名称并且可以取消删除通过重命名它。当隐藏文件从命名空间删除，它在内存中的原数据被擦除。这个有效的切断文件和它包含的所有的Chunk的连接。
* 在对Chunk命名空间的常规扫描中。Master标记孤儿Chunk（不被任何文件包含的Chunk）并且擦除这些Chunk的原数据。在与master 交互的心跳信息中，每个Chunk(块)服务器报告它所拥有的Chunk子集信息，并且master回复Chunk 服务器 master元数据中不存在的所有Chunk。Chunk(块)服务器可以随意删除这些Chunk的副本。

#### 4.4.2 讨论

* 尽管分布式的垃圾回收是一个在编程语言中需要复杂的解决方案的难题。在我们的案例中非常简单。我们可以简单地获得有Chunk所有引用：存储在master的文件到块的映射表中。我们也可以简单的获得所有的Chunk副本：它们是每个Chunk(块)服务器中定义好的目录下的linux文件。任何不被Master知道的副本都是 “垃圾”。
* 垃圾回收相较于直接删除在空间回收上有几个优势。首先，这很简单并且可靠在一个组件失效是常态的大型的分布式系统中。Chunk创建可能在某些副本中成功而其他中不成功，失败的副本 处于Master 无法是别的状态。副本删除消息或许会丢失，Master需要记得重发删除消息包括它自身以及Chunk(块)服务器。垃圾回收提供一个统一的可靠的方式去清除无用的副本。第二，它合并存储空间回收操作到master的后台活动中。例如定期的命名空间扫描以及和Chunk(块)服务器的握手。因此这些是批量处理并且开销被分摊了。另外,垃圾回收只有Master相对空闲时候执行。Master可以快速响应那些更多需要快速反映的的客户端请求。第三，回收垃圾的延迟操作为意外，不可逆的删除提供了安全保障。
* 根据我们的使用经验，主要地缺点是延迟在存储紧缺时候有时阻碍用户的调优操作，应用快速的创建和删除临时文件或者不会去正确的释放空间。我们通过显式的再次删除一个被删除文件的方式 加速空间回收。我们也允许用户使用不同的复制或者回收策略在不同而命名空间上。例如，用户可以指定某些目录树下的文件不做复制，并且删除的文件被立即，不可恢复的从文件系统中删除。

#### 4.5 过期的副本检测

* Chunk(块)服务器失败或者在它宕机时候Chunk副本可能过期因为错过一些修改操作。对每个Chunk，Master 维持一个Chunk版本号来区分最新的和过期的副本
* 无论何时，Master 和Chunk签订一个新的租约，它增加Chunk的版本号，通知最新的副本。Master 和这些副本都记录新的版本号在自己的持久化存储的状态信息中。这些发生在所有客户端被通知前。因此发生在开始写Chunk之前。如果某个副本当下不可用，它的Chunk版本号将被更新。Master 将会检测这个Chunk(块)服务器有一个过期的副本，当这个Chunk服务重启并且报告自己的副本集和它的关联版本号。如果master 看到一个版本号大于自己记录里面的版本号。Master 假定它在授权租约时候失败并且用最高的版本号更新当前版本号。
* Master 在定期的垃圾收集中删除过期的副本。在这之前，它简单的认为过期的副本不存在当它应答客户端的请求Chunk信息时。 另一个防护措施，Master通知客户端哪个Chunk(块)服务器拥有租约，或者 它授权一个Chunk(块)服务器从其他Chunk(块)服务器复制时，消息都附带了Chunk的版本号。客户端或者Chunk(块)服务器校验版本号当它执行操作以确保它总是获得最新的数据。